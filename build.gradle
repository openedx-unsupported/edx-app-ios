import org.apache.commons.configuration.plist.*
import org.edx.builder.TaskHelper

// Dependencies
buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'commons-configuration:commons-configuration:1.10'
    }
}

apply plugin: 'edxapp'
edx {
    platform = IOS
}

// Configuration
def workspace = 'edX.xcworkspace'
def scheme = 'edX'

class IOSHelper {
    // Environment Variable Conveniences
    // Only valid when our task is invoked by an Xcode build

    def getInfoPlistPath() {
        def env = System.getenv()
        return env['INFOPLIST_PATH']
    }

    def getBuiltProductsPath() {
        def env = System.getenv()
        return env['BUILT_PRODUCTS_DIR']
    }

    def getWrapperName() {
        def env = System.getenv()
        return env['WRAPPER_NAME']
    }

    def getBuiltInfoPlistPath() {
        return builtProductsPath + '/' + infoPlistPath
    }

    def getBundleConfigPath() {
        return builtProductsPath + '/' + wrapperName + '/config.plist'
    }

    // Saves our loaded and processed config YAML
    // to a Plist in the app bundle
    def saveProcessedConfig(config, toPath) {
        def plist = new XMLPropertyListConfiguration()

        for(c in config) {
            plist.addProperty(c.key, c.value)
        }

        // Save entire config
        plist.save(new FileWriter(toPath))
    }

    // Modify Info.plist for specific services

    def readInfoPlist() {
        // The configuration library doesn't know how to read
        // binary plists so make sure it's an xml one
        ['plutil', '-convert', 'xml1', builtInfoPlistPath].execute().waitFor()

        def plist = new XMLPropertyListConfiguration()
        plist.load(new FileReader(builtInfoPlistPath))
        return plist
    }

    def writeInfoPlist(plist) {
        plist.save(new FileWriter(builtInfoPlistPath))

        // Restore to binary for runtime performance
        ['plutil', '-convert', 'binary1', builtInfoPlistPath].execute().waitFor()
    }

    def addURLScheme(scheme, plist) {
        def body = [
            'CFBundleTypeRole' : 'Editor',
            'CFBundleURLSchemes' : [scheme]
        ]

        def existing = plist.getProperty('CFBundleURLTypes')
        if(existing) {
            // make sure we don't add it more than once
            def found = false
            for(entry in existing){
                def schemes = entry.getProperty('CFBundleURLSchemes')
                if(schemes && schemes.contains(scheme)){
                    found = true
                    break
                }
            }
            if(!found) {
                existing.add(body)
            }
        }
        else {
            plist.addProperty("CFBundleURLTypes", [body])
        }
    }

    def addFacebookConfig(config, plist) {
        def facebook = config['FACEBOOK'] ?: [:]
        def key = facebook['FACEBOOK_APP_ID']
        if(!key) {
            return
        }

        plist.addProperty("FacebookAppID", key)
        def scheme = "fb" + key
        addURLScheme(scheme, plist)
    }

    def addFabricConfig(config, plist) {
        def fabric = config['FABRIC'] ?: [:]
        
        def key = fabric['FABRIC_KEY']
        if(!key) {
            return
        }

        def body = [
            'APIKey' : key,
            'Kits' : [
                [
                    'KitInfo' : [],
                    'KitName' : 'Crashlytics'
                ]
            ]
        ]
        plist.addProperty("Fabric", body)
    }

}


// Tasks 
task printBuildEnvironment(type : Exec) {
    def arguments = [
        'xcodebuild',
        '-workspace', workspace,
        '-scheme', scheme,
        '-showBuildSettings'
    ]
    commandLine arguments
}

task uploadDebuggingSymbols << {
    def taskHelper = new TaskHelper()
    def config = taskHelper.loadConfig(project)
    def fabric = config['FABRIC'] ?: [:]
    def key = fabric['FABRIC_KEY']
    def secret = fabric['FABRIC_BUILD_SECRET']
    def srcroot = System.getenv()['SRCROOT']
    if(key && secret && srcroot) {
        [srcroot + "/Libraries/Fabric.framework/run", key, secret].execute().waitFor()
    }
}

task applyConfig << {
    def taskHelper = new TaskHelper()
    def config = taskHelper.loadConfig(project)
    def helper = new IOSHelper()

    // Save all keys to config.plist
    helper.saveProcessedConfig(config, helper.bundleConfigPath)

    // Save specific fields to Info.plist
    def plist = helper.readInfoPlist()
    helper.addFacebookConfig(config, plist)
    helper.addFabricConfig(config, plist)
    helper.writeInfoPlist(plist)

    // double check that the config file actually got made
    def check = ["[", "-f", helper.bundleConfigPath, "]"].execute()
    check.waitFor()

    def result = check.exitValue()
    assert result == 0
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.2.1'
}

def testBuildArguments(workspace, scheme) {
    return [
        'xctool', '-workspace', workspace, '-scheme', scheme, '-sdk', 'iphonesimulator', '-reporter', 'pretty', 'test'
    ]
}

def RTLSchemeForScheme(scheme) {
    return scheme + '-RTL'
}

def recordSnapshotsBuildArguments(workspace, scheme) {
    return testBuildArguments(workspace, scheme) + "OTHER_SWIFT_FLAGS=\$(OTHER_SWIFT_FLAGS) -D RECORD_SNAPSHOTS"
}

task testDefault(type : Exec) {
    commandLine testBuildArguments(workspace, scheme)
}

task testRTL(type : Exec) {
    commandLine testBuildArguments(workspace, RTLSchemeForScheme(scheme))
}

task recordSnapshotsDefault(type : Exec) {
    commandLine recordSnapshotsBuildArguments(workspace, scheme)
}

task recordSnapshotsRTL(type : Exec) {
    commandLine recordSnapshotsBuildArguments(workspace, RTLSchemeForScheme(scheme))
}

task recordSnapshots(dependsOn : [recordSnapshotsDefault, recordSnapshotsRTL]) { }

task test(dependsOn : [testDefault, testRTL]) { }

