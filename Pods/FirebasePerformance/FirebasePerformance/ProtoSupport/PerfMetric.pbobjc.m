// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perf_metric.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "PerfMetric.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(FPRMSGAndroidApplicationInfo);
GPBObjCClassDeclaration(FPRMSGAndroidMemoryReading);
GPBObjCClassDeclaration(FPRMSGApplicationInfo);
GPBObjCClassDeclaration(FPRMSGCpuMetricReading);
GPBObjCClassDeclaration(FPRMSGGaugeMetadata);
GPBObjCClassDeclaration(FPRMSGGaugeMetric);
GPBObjCClassDeclaration(FPRMSGIosApplicationInfo);
GPBObjCClassDeclaration(FPRMSGIosMemoryReading);
GPBObjCClassDeclaration(FPRMSGNetworkConnectionInfo);
GPBObjCClassDeclaration(FPRMSGNetworkRequestMetric);
GPBObjCClassDeclaration(FPRMSGPerfSession);
GPBObjCClassDeclaration(FPRMSGTraceMetric);
GPBObjCClassDeclaration(FPRMSGTransportInfo);
GPBObjCClassDeclaration(FPRMSGWebApplicationInfo);

#pragma mark - FPRMSGPerfMetricRoot

@implementation FPRMSGPerfMetricRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - FPRMSGPerfMetricRoot_FileDescriptor

static GPBFileDescriptor *FPRMSGPerfMetricRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"firebase.perf.v1"
                                                 objcPrefix:@"FPRMSG"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum FPRMSGApplicationProcessState

GPBEnumDescriptor *FPRMSGApplicationProcessState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ApplicationProcessStateUnknown\000Foregroun"
        "d\000Background\000ForegroundBackground\000";
    static const int32_t values[] = {
        FPRMSGApplicationProcessState_ApplicationProcessStateUnknown,
        FPRMSGApplicationProcessState_Foreground,
        FPRMSGApplicationProcessState_Background,
        FPRMSGApplicationProcessState_ForegroundBackground,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FPRMSGApplicationProcessState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FPRMSGApplicationProcessState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FPRMSGApplicationProcessState_IsValidValue(int32_t value__) {
  switch (value__) {
    case FPRMSGApplicationProcessState_ApplicationProcessStateUnknown:
    case FPRMSGApplicationProcessState_Foreground:
    case FPRMSGApplicationProcessState_Background:
    case FPRMSGApplicationProcessState_ForegroundBackground:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FPRMSGSessionVerbosity

GPBEnumDescriptor *FPRMSGSessionVerbosity_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SessionVerbosityNone\000GaugesAndSystemEven"
        "ts\000";
    static const int32_t values[] = {
        FPRMSGSessionVerbosity_SessionVerbosityNone,
        FPRMSGSessionVerbosity_GaugesAndSystemEvents,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FPRMSGSessionVerbosity)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FPRMSGSessionVerbosity_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FPRMSGSessionVerbosity_IsValidValue(int32_t value__) {
  switch (value__) {
    case FPRMSGSessionVerbosity_SessionVerbosityNone:
    case FPRMSGSessionVerbosity_GaugesAndSystemEvents:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FPRMSGVisibilityState

GPBEnumDescriptor *FPRMSGVisibilityState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VisibilityStateUnknown\000Visible\000Hidden\000Pr"
        "erender\000Unloaded\000";
    static const int32_t values[] = {
        FPRMSGVisibilityState_VisibilityStateUnknown,
        FPRMSGVisibilityState_Visible,
        FPRMSGVisibilityState_Hidden,
        FPRMSGVisibilityState_Prerender,
        FPRMSGVisibilityState_Unloaded,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FPRMSGVisibilityState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FPRMSGVisibilityState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FPRMSGVisibilityState_IsValidValue(int32_t value__) {
  switch (value__) {
    case FPRMSGVisibilityState_VisibilityStateUnknown:
    case FPRMSGVisibilityState_Visible:
    case FPRMSGVisibilityState_Hidden:
    case FPRMSGVisibilityState_Prerender:
    case FPRMSGVisibilityState_Unloaded:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FPRMSGServiceWorkerStatus

GPBEnumDescriptor *FPRMSGServiceWorkerStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ServiceWorkerStatusUnknown\000Unsupported\000C"
        "ontrolled\000Uncontrolled\000";
    static const int32_t values[] = {
        FPRMSGServiceWorkerStatus_ServiceWorkerStatusUnknown,
        FPRMSGServiceWorkerStatus_Unsupported,
        FPRMSGServiceWorkerStatus_Controlled,
        FPRMSGServiceWorkerStatus_Uncontrolled,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FPRMSGServiceWorkerStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FPRMSGServiceWorkerStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FPRMSGServiceWorkerStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case FPRMSGServiceWorkerStatus_ServiceWorkerStatusUnknown:
    case FPRMSGServiceWorkerStatus_Unsupported:
    case FPRMSGServiceWorkerStatus_Controlled:
    case FPRMSGServiceWorkerStatus_Uncontrolled:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FPRMSGEffectiveConnectionType

GPBEnumDescriptor *FPRMSGEffectiveConnectionType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EffectiveConnectionTypeUnknown\000Effective"
        "ConnectionTypeSlow2G\000EffectiveConnection"
        "Type2G\000EffectiveConnectionType3G\000Effecti"
        "veConnectionType4G\000";
    static const int32_t values[] = {
        FPRMSGEffectiveConnectionType_EffectiveConnectionTypeUnknown,
        FPRMSGEffectiveConnectionType_EffectiveConnectionTypeSlow2G,
        FPRMSGEffectiveConnectionType_EffectiveConnectionType2G,
        FPRMSGEffectiveConnectionType_EffectiveConnectionType3G,
        FPRMSGEffectiveConnectionType_EffectiveConnectionType4G,
    };
    static const char *extraTextFormatInfo = "\004\001i\352\344\344\202\000\002i\352\344\202\000\003i\352\344\202\000\004i\352\344\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FPRMSGEffectiveConnectionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FPRMSGEffectiveConnectionType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FPRMSGEffectiveConnectionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case FPRMSGEffectiveConnectionType_EffectiveConnectionTypeUnknown:
    case FPRMSGEffectiveConnectionType_EffectiveConnectionTypeSlow2G:
    case FPRMSGEffectiveConnectionType_EffectiveConnectionType2G:
    case FPRMSGEffectiveConnectionType_EffectiveConnectionType3G:
    case FPRMSGEffectiveConnectionType_EffectiveConnectionType4G:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - FPRMSGPerfMetric

@implementation FPRMSGPerfMetric

@dynamic hasApplicationInfo, applicationInfo;
@dynamic hasTraceMetric, traceMetric;
@dynamic hasNetworkRequestMetric, networkRequestMetric;
@dynamic hasGaugeMetric, gaugeMetric;
@dynamic hasTransportInfo, transportInfo;

typedef struct FPRMSGPerfMetric__storage_ {
  uint32_t _has_storage_[1];
  FPRMSGApplicationInfo *applicationInfo;
  FPRMSGTraceMetric *traceMetric;
  FPRMSGNetworkRequestMetric *networkRequestMetric;
  FPRMSGGaugeMetric *gaugeMetric;
  FPRMSGTransportInfo *transportInfo;
} FPRMSGPerfMetric__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "applicationInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGApplicationInfo),
        .number = FPRMSGPerfMetric_FieldNumber_ApplicationInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGPerfMetric__storage_, applicationInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "traceMetric",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGTraceMetric),
        .number = FPRMSGPerfMetric_FieldNumber_TraceMetric,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPRMSGPerfMetric__storage_, traceMetric),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkRequestMetric",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGNetworkRequestMetric),
        .number = FPRMSGPerfMetric_FieldNumber_NetworkRequestMetric,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FPRMSGPerfMetric__storage_, networkRequestMetric),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gaugeMetric",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGGaugeMetric),
        .number = FPRMSGPerfMetric_FieldNumber_GaugeMetric,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FPRMSGPerfMetric__storage_, gaugeMetric),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transportInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGTransportInfo),
        .number = FPRMSGPerfMetric_FieldNumber_TransportInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FPRMSGPerfMetric__storage_, transportInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGPerfMetric class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGPerfMetric__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPRMSGTraceMetric

@implementation FPRMSGTraceMetric

@dynamic hasName, name;
@dynamic hasIsAuto, isAuto;
@dynamic hasClientStartTimeUs, clientStartTimeUs;
@dynamic hasDurationUs, durationUs;
@dynamic counters, counters_Count;
@dynamic subtracesArray, subtracesArray_Count;
@dynamic customAttributes, customAttributes_Count;
@dynamic perfSessionsArray, perfSessionsArray_Count;

typedef struct FPRMSGTraceMetric__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  GPBStringInt64Dictionary *counters;
  NSMutableArray *subtracesArray;
  NSMutableDictionary *customAttributes;
  NSMutableArray *perfSessionsArray;
  int64_t clientStartTimeUs;
  int64_t durationUs;
} FPRMSGTraceMetric__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGTraceMetric_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGTraceMetric__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAuto",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGTraceMetric_FieldNumber_IsAuto,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "clientStartTimeUs",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGTraceMetric_FieldNumber_ClientStartTimeUs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FPRMSGTraceMetric__storage_, clientStartTimeUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "durationUs",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGTraceMetric_FieldNumber_DurationUs,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FPRMSGTraceMetric__storage_, durationUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "counters",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGTraceMetric_FieldNumber_Counters,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FPRMSGTraceMetric__storage_, counters),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "subtracesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGTraceMetric),
        .number = FPRMSGTraceMetric_FieldNumber_SubtracesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FPRMSGTraceMetric__storage_, subtracesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "customAttributes",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGTraceMetric_FieldNumber_CustomAttributes,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FPRMSGTraceMetric__storage_, customAttributes),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "perfSessionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGPerfSession),
        .number = FPRMSGTraceMetric_FieldNumber_PerfSessionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FPRMSGTraceMetric__storage_, perfSessionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGTraceMetric class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGTraceMetric__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPRMSGNetworkRequestMetric

@implementation FPRMSGNetworkRequestMetric

@dynamic hasURL, URL;
@dynamic hasHTTPMethod, HTTPMethod;
@dynamic hasRequestPayloadBytes, requestPayloadBytes;
@dynamic hasResponsePayloadBytes, responsePayloadBytes;
@dynamic hasNetworkClientErrorReason, networkClientErrorReason;
@dynamic hasHTTPResponseCode, HTTPResponseCode;
@dynamic hasResponseContentType, responseContentType;
@dynamic hasClientStartTimeUs, clientStartTimeUs;
@dynamic hasTimeToRequestCompletedUs, timeToRequestCompletedUs;
@dynamic hasTimeToResponseInitiatedUs, timeToResponseInitiatedUs;
@dynamic hasTimeToResponseCompletedUs, timeToResponseCompletedUs;
@dynamic customAttributes, customAttributes_Count;
@dynamic perfSessionsArray, perfSessionsArray_Count;

typedef struct FPRMSGNetworkRequestMetric__storage_ {
  uint32_t _has_storage_[1];
  FPRMSGNetworkRequestMetric_HttpMethod HTTPMethod;
  int32_t HTTPResponseCode;
  FPRMSGNetworkRequestMetric_NetworkClientErrorReason networkClientErrorReason;
  NSString *URL;
  NSString *responseContentType;
  NSMutableDictionary *customAttributes;
  NSMutableArray *perfSessionsArray;
  int64_t requestPayloadBytes;
  int64_t responsePayloadBytes;
  int64_t clientStartTimeUs;
  int64_t timeToRequestCompletedUs;
  int64_t timeToResponseInitiatedUs;
  int64_t timeToResponseCompletedUs;
} FPRMSGNetworkRequestMetric__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGNetworkRequestMetric_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGNetworkRequestMetric__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "HTTPMethod",
        .dataTypeSpecific.enumDescFunc = FPRMSGNetworkRequestMetric_HttpMethod_EnumDescriptor,
        .number = FPRMSGNetworkRequestMetric_FieldNumber_HTTPMethod,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPRMSGNetworkRequestMetric__storage_, HTTPMethod),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "requestPayloadBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGNetworkRequestMetric_FieldNumber_RequestPayloadBytes,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FPRMSGNetworkRequestMetric__storage_, requestPayloadBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "responsePayloadBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGNetworkRequestMetric_FieldNumber_ResponsePayloadBytes,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FPRMSGNetworkRequestMetric__storage_, responsePayloadBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "HTTPResponseCode",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGNetworkRequestMetric_FieldNumber_HTTPResponseCode,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FPRMSGNetworkRequestMetric__storage_, HTTPResponseCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "responseContentType",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGNetworkRequestMetric_FieldNumber_ResponseContentType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FPRMSGNetworkRequestMetric__storage_, responseContentType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientStartTimeUs",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGNetworkRequestMetric_FieldNumber_ClientStartTimeUs,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FPRMSGNetworkRequestMetric__storage_, clientStartTimeUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timeToRequestCompletedUs",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGNetworkRequestMetric_FieldNumber_TimeToRequestCompletedUs,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(FPRMSGNetworkRequestMetric__storage_, timeToRequestCompletedUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timeToResponseInitiatedUs",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGNetworkRequestMetric_FieldNumber_TimeToResponseInitiatedUs,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(FPRMSGNetworkRequestMetric__storage_, timeToResponseInitiatedUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "timeToResponseCompletedUs",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGNetworkRequestMetric_FieldNumber_TimeToResponseCompletedUs,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(FPRMSGNetworkRequestMetric__storage_, timeToResponseCompletedUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "networkClientErrorReason",
        .dataTypeSpecific.enumDescFunc = FPRMSGNetworkRequestMetric_NetworkClientErrorReason_EnumDescriptor,
        .number = FPRMSGNetworkRequestMetric_FieldNumber_NetworkClientErrorReason,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FPRMSGNetworkRequestMetric__storage_, networkClientErrorReason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "customAttributes",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGNetworkRequestMetric_FieldNumber_CustomAttributes,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FPRMSGNetworkRequestMetric__storage_, customAttributes),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "perfSessionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGPerfSession),
        .number = FPRMSGNetworkRequestMetric_FieldNumber_PerfSessionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FPRMSGNetworkRequestMetric__storage_, perfSessionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGNetworkRequestMetric class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGNetworkRequestMetric__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001!!!\000\002!!!!\246\000\005!!!!\250\244\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum FPRMSGNetworkRequestMetric_HttpMethod

GPBEnumDescriptor *FPRMSGNetworkRequestMetric_HttpMethod_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "HTTPMethodUnknown\000Get\000Put\000Post\000Delete\000He"
        "ad\000Patch\000Options\000Trace\000Connect\000";
    static const int32_t values[] = {
        FPRMSGNetworkRequestMetric_HttpMethod_HTTPMethodUnknown,
        FPRMSGNetworkRequestMetric_HttpMethod_Get,
        FPRMSGNetworkRequestMetric_HttpMethod_Put,
        FPRMSGNetworkRequestMetric_HttpMethod_Post,
        FPRMSGNetworkRequestMetric_HttpMethod_Delete,
        FPRMSGNetworkRequestMetric_HttpMethod_Head,
        FPRMSGNetworkRequestMetric_HttpMethod_Patch,
        FPRMSGNetworkRequestMetric_HttpMethod_Options,
        FPRMSGNetworkRequestMetric_HttpMethod_Trace,
        FPRMSGNetworkRequestMetric_HttpMethod_Connect,
    };
    static const char *extraTextFormatInfo = "\001\000\004\346\347\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FPRMSGNetworkRequestMetric_HttpMethod)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FPRMSGNetworkRequestMetric_HttpMethod_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FPRMSGNetworkRequestMetric_HttpMethod_IsValidValue(int32_t value__) {
  switch (value__) {
    case FPRMSGNetworkRequestMetric_HttpMethod_HTTPMethodUnknown:
    case FPRMSGNetworkRequestMetric_HttpMethod_Get:
    case FPRMSGNetworkRequestMetric_HttpMethod_Put:
    case FPRMSGNetworkRequestMetric_HttpMethod_Post:
    case FPRMSGNetworkRequestMetric_HttpMethod_Delete:
    case FPRMSGNetworkRequestMetric_HttpMethod_Head:
    case FPRMSGNetworkRequestMetric_HttpMethod_Patch:
    case FPRMSGNetworkRequestMetric_HttpMethod_Options:
    case FPRMSGNetworkRequestMetric_HttpMethod_Trace:
    case FPRMSGNetworkRequestMetric_HttpMethod_Connect:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FPRMSGNetworkRequestMetric_NetworkClientErrorReason

GPBEnumDescriptor *FPRMSGNetworkRequestMetric_NetworkClientErrorReason_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NetworkClientErrorReasonUnknown\000GenericC"
        "lientError\000";
    static const int32_t values[] = {
        FPRMSGNetworkRequestMetric_NetworkClientErrorReason_NetworkClientErrorReasonUnknown,
        FPRMSGNetworkRequestMetric_NetworkClientErrorReason_GenericClientError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FPRMSGNetworkRequestMetric_NetworkClientErrorReason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FPRMSGNetworkRequestMetric_NetworkClientErrorReason_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FPRMSGNetworkRequestMetric_NetworkClientErrorReason_IsValidValue(int32_t value__) {
  switch (value__) {
    case FPRMSGNetworkRequestMetric_NetworkClientErrorReason_NetworkClientErrorReasonUnknown:
    case FPRMSGNetworkRequestMetric_NetworkClientErrorReason_GenericClientError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - FPRMSGPerfSession

@implementation FPRMSGPerfSession

@dynamic hasSessionId, sessionId;
@dynamic sessionVerbosityArray, sessionVerbosityArray_Count;

typedef struct FPRMSGPerfSession__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  GPBEnumArray *sessionVerbosityArray;
} FPRMSGPerfSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGPerfSession_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGPerfSession__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionVerbosityArray",
        .dataTypeSpecific.enumDescFunc = FPRMSGSessionVerbosity_EnumDescriptor,
        .number = FPRMSGPerfSession_FieldNumber_SessionVerbosityArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FPRMSGPerfSession__storage_, sessionVerbosityArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGPerfSession class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGPerfSession__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPRMSGGaugeMetric

@implementation FPRMSGGaugeMetric

@dynamic hasSessionId, sessionId;
@dynamic hasGaugeMetadata, gaugeMetadata;
@dynamic cpuMetricReadingsArray, cpuMetricReadingsArray_Count;
@dynamic androidMemoryReadingsArray, androidMemoryReadingsArray_Count;
@dynamic iosMemoryReadingsArray, iosMemoryReadingsArray_Count;

typedef struct FPRMSGGaugeMetric__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  NSMutableArray *cpuMetricReadingsArray;
  FPRMSGGaugeMetadata *gaugeMetadata;
  NSMutableArray *androidMemoryReadingsArray;
  NSMutableArray *iosMemoryReadingsArray;
} FPRMSGGaugeMetric__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGGaugeMetric_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGGaugeMetric__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cpuMetricReadingsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGCpuMetricReading),
        .number = FPRMSGGaugeMetric_FieldNumber_CpuMetricReadingsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FPRMSGGaugeMetric__storage_, cpuMetricReadingsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gaugeMetadata",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGGaugeMetadata),
        .number = FPRMSGGaugeMetric_FieldNumber_GaugeMetadata,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPRMSGGaugeMetric__storage_, gaugeMetadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "androidMemoryReadingsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGAndroidMemoryReading),
        .number = FPRMSGGaugeMetric_FieldNumber_AndroidMemoryReadingsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FPRMSGGaugeMetric__storage_, androidMemoryReadingsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "iosMemoryReadingsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGIosMemoryReading),
        .number = FPRMSGGaugeMetric_FieldNumber_IosMemoryReadingsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FPRMSGGaugeMetric__storage_, iosMemoryReadingsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGGaugeMetric class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGGaugeMetric__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPRMSGCpuMetricReading

@implementation FPRMSGCpuMetricReading

@dynamic hasClientTimeUs, clientTimeUs;
@dynamic hasUserTimeUs, userTimeUs;
@dynamic hasSystemTimeUs, systemTimeUs;

typedef struct FPRMSGCpuMetricReading__storage_ {
  uint32_t _has_storage_[1];
  int64_t clientTimeUs;
  int64_t userTimeUs;
  int64_t systemTimeUs;
} FPRMSGCpuMetricReading__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clientTimeUs",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGCpuMetricReading_FieldNumber_ClientTimeUs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGCpuMetricReading__storage_, clientTimeUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userTimeUs",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGCpuMetricReading_FieldNumber_UserTimeUs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPRMSGCpuMetricReading__storage_, userTimeUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "systemTimeUs",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGCpuMetricReading_FieldNumber_SystemTimeUs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FPRMSGCpuMetricReading__storage_, systemTimeUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGCpuMetricReading class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGCpuMetricReading__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPRMSGIosMemoryReading

@implementation FPRMSGIosMemoryReading

@dynamic hasClientTimeUs, clientTimeUs;
@dynamic hasUsedAppHeapMemoryKb, usedAppHeapMemoryKb;
@dynamic hasFreeAppHeapMemoryKb, freeAppHeapMemoryKb;

typedef struct FPRMSGIosMemoryReading__storage_ {
  uint32_t _has_storage_[1];
  int32_t usedAppHeapMemoryKb;
  int32_t freeAppHeapMemoryKb;
  int64_t clientTimeUs;
} FPRMSGIosMemoryReading__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clientTimeUs",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGIosMemoryReading_FieldNumber_ClientTimeUs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGIosMemoryReading__storage_, clientTimeUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "usedAppHeapMemoryKb",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGIosMemoryReading_FieldNumber_UsedAppHeapMemoryKb,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPRMSGIosMemoryReading__storage_, usedAppHeapMemoryKb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "freeAppHeapMemoryKb",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGIosMemoryReading_FieldNumber_FreeAppHeapMemoryKb,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FPRMSGIosMemoryReading__storage_, freeAppHeapMemoryKb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGIosMemoryReading class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGIosMemoryReading__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPRMSGAndroidMemoryReading

@implementation FPRMSGAndroidMemoryReading

@dynamic hasClientTimeUs, clientTimeUs;
@dynamic hasUsedAppJavaHeapMemoryKb, usedAppJavaHeapMemoryKb;

typedef struct FPRMSGAndroidMemoryReading__storage_ {
  uint32_t _has_storage_[1];
  int32_t usedAppJavaHeapMemoryKb;
  int64_t clientTimeUs;
} FPRMSGAndroidMemoryReading__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clientTimeUs",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGAndroidMemoryReading_FieldNumber_ClientTimeUs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGAndroidMemoryReading__storage_, clientTimeUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "usedAppJavaHeapMemoryKb",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGAndroidMemoryReading_FieldNumber_UsedAppJavaHeapMemoryKb,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPRMSGAndroidMemoryReading__storage_, usedAppJavaHeapMemoryKb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGAndroidMemoryReading class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGAndroidMemoryReading__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPRMSGGaugeMetadata

@implementation FPRMSGGaugeMetadata

@dynamic hasProcessName, processName;
@dynamic hasCpuClockRateKhz, cpuClockRateKhz;
@dynamic hasCpuProcessorCount, cpuProcessorCount;
@dynamic hasDeviceRamSizeKb, deviceRamSizeKb;
@dynamic hasMaxAppJavaHeapMemoryKb, maxAppJavaHeapMemoryKb;
@dynamic hasMaxEncouragedAppJavaHeapMemoryKb, maxEncouragedAppJavaHeapMemoryKb;

typedef struct FPRMSGGaugeMetadata__storage_ {
  uint32_t _has_storage_[1];
  int32_t cpuClockRateKhz;
  int32_t deviceRamSizeKb;
  int32_t maxAppJavaHeapMemoryKb;
  int32_t maxEncouragedAppJavaHeapMemoryKb;
  int32_t cpuProcessorCount;
  NSString *processName;
} FPRMSGGaugeMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "processName",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGGaugeMetadata_FieldNumber_ProcessName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGGaugeMetadata__storage_, processName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cpuClockRateKhz",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGGaugeMetadata_FieldNumber_CpuClockRateKhz,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPRMSGGaugeMetadata__storage_, cpuClockRateKhz),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceRamSizeKb",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGGaugeMetadata_FieldNumber_DeviceRamSizeKb,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FPRMSGGaugeMetadata__storage_, deviceRamSizeKb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxAppJavaHeapMemoryKb",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGGaugeMetadata_FieldNumber_MaxAppJavaHeapMemoryKb,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FPRMSGGaugeMetadata__storage_, maxAppJavaHeapMemoryKb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxEncouragedAppJavaHeapMemoryKb",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGGaugeMetadata_FieldNumber_MaxEncouragedAppJavaHeapMemoryKb,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FPRMSGGaugeMetadata__storage_, maxEncouragedAppJavaHeapMemoryKb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cpuProcessorCount",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGGaugeMetadata_FieldNumber_CpuProcessorCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FPRMSGGaugeMetadata__storage_, cpuProcessorCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGGaugeMetadata class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGGaugeMetadata__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPRMSGApplicationInfo

@implementation FPRMSGApplicationInfo

@dynamic hasGoogleAppId, googleAppId;
@dynamic hasAppInstanceId, appInstanceId;
@dynamic hasAndroidAppInfo, androidAppInfo;
@dynamic hasIosAppInfo, iosAppInfo;
@dynamic hasWebAppInfo, webAppInfo;
@dynamic hasApplicationProcessState, applicationProcessState;
@dynamic customAttributes, customAttributes_Count;

typedef struct FPRMSGApplicationInfo__storage_ {
  uint32_t _has_storage_[1];
  FPRMSGApplicationProcessState applicationProcessState;
  NSString *googleAppId;
  NSString *appInstanceId;
  FPRMSGAndroidApplicationInfo *androidAppInfo;
  FPRMSGIosApplicationInfo *iosAppInfo;
  NSMutableDictionary *customAttributes;
  FPRMSGWebApplicationInfo *webAppInfo;
} FPRMSGApplicationInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "googleAppId",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGApplicationInfo_FieldNumber_GoogleAppId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGApplicationInfo__storage_, googleAppId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appInstanceId",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGApplicationInfo_FieldNumber_AppInstanceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPRMSGApplicationInfo__storage_, appInstanceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidAppInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGAndroidApplicationInfo),
        .number = FPRMSGApplicationInfo_FieldNumber_AndroidAppInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FPRMSGApplicationInfo__storage_, androidAppInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "iosAppInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGIosApplicationInfo),
        .number = FPRMSGApplicationInfo_FieldNumber_IosAppInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FPRMSGApplicationInfo__storage_, iosAppInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "applicationProcessState",
        .dataTypeSpecific.enumDescFunc = FPRMSGApplicationProcessState_EnumDescriptor,
        .number = FPRMSGApplicationInfo_FieldNumber_ApplicationProcessState,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FPRMSGApplicationInfo__storage_, applicationProcessState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "customAttributes",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGApplicationInfo_FieldNumber_CustomAttributes,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FPRMSGApplicationInfo__storage_, customAttributes),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "webAppInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGWebApplicationInfo),
        .number = FPRMSGApplicationInfo_FieldNumber_WebAppInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FPRMSGApplicationInfo__storage_, webAppInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGApplicationInfo class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGApplicationInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPRMSGWebApplicationInfo

@implementation FPRMSGWebApplicationInfo

@dynamic hasSdkVersion, sdkVersion;
@dynamic hasPageURL, pageURL;
@dynamic hasServiceWorkerStatus, serviceWorkerStatus;
@dynamic hasVisibilityState, visibilityState;
@dynamic hasEffectiveConnectionType, effectiveConnectionType;

typedef struct FPRMSGWebApplicationInfo__storage_ {
  uint32_t _has_storage_[1];
  FPRMSGServiceWorkerStatus serviceWorkerStatus;
  FPRMSGVisibilityState visibilityState;
  FPRMSGEffectiveConnectionType effectiveConnectionType;
  NSString *sdkVersion;
  NSString *pageURL;
} FPRMSGWebApplicationInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sdkVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGWebApplicationInfo_FieldNumber_SdkVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGWebApplicationInfo__storage_, sdkVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pageURL",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGWebApplicationInfo_FieldNumber_PageURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPRMSGWebApplicationInfo__storage_, pageURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serviceWorkerStatus",
        .dataTypeSpecific.enumDescFunc = FPRMSGServiceWorkerStatus_EnumDescriptor,
        .number = FPRMSGWebApplicationInfo_FieldNumber_ServiceWorkerStatus,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FPRMSGWebApplicationInfo__storage_, serviceWorkerStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "visibilityState",
        .dataTypeSpecific.enumDescFunc = FPRMSGVisibilityState_EnumDescriptor,
        .number = FPRMSGWebApplicationInfo_FieldNumber_VisibilityState,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FPRMSGWebApplicationInfo__storage_, visibilityState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "effectiveConnectionType",
        .dataTypeSpecific.enumDescFunc = FPRMSGEffectiveConnectionType_EnumDescriptor,
        .number = FPRMSGWebApplicationInfo_FieldNumber_EffectiveConnectionType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FPRMSGWebApplicationInfo__storage_, effectiveConnectionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGWebApplicationInfo class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGWebApplicationInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPRMSGAndroidApplicationInfo

@implementation FPRMSGAndroidApplicationInfo

@dynamic hasPackageName, packageName;
@dynamic hasSdkVersion, sdkVersion;
@dynamic hasVersionName, versionName;

typedef struct FPRMSGAndroidApplicationInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *packageName;
  NSString *sdkVersion;
  NSString *versionName;
} FPRMSGAndroidApplicationInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "packageName",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGAndroidApplicationInfo_FieldNumber_PackageName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGAndroidApplicationInfo__storage_, packageName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sdkVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGAndroidApplicationInfo_FieldNumber_SdkVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPRMSGAndroidApplicationInfo__storage_, sdkVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "versionName",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGAndroidApplicationInfo_FieldNumber_VersionName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FPRMSGAndroidApplicationInfo__storage_, versionName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGAndroidApplicationInfo class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGAndroidApplicationInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPRMSGNetworkConnectionInfo

@implementation FPRMSGNetworkConnectionInfo

@dynamic hasNetworkType, networkType;
@dynamic hasMobileSubtype, mobileSubtype;

typedef struct FPRMSGNetworkConnectionInfo__storage_ {
  uint32_t _has_storage_[1];
  FPRMSGNetworkConnectionInfo_NetworkType networkType;
  FPRMSGNetworkConnectionInfo_MobileSubtype mobileSubtype;
} FPRMSGNetworkConnectionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = FPRMSGNetworkConnectionInfo_NetworkType_None,
        .core.name = "networkType",
        .core.dataTypeSpecific.enumDescFunc = FPRMSGNetworkConnectionInfo_NetworkType_EnumDescriptor,
        .core.number = FPRMSGNetworkConnectionInfo_FieldNumber_NetworkType,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(FPRMSGNetworkConnectionInfo__storage_, networkType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = FPRMSGNetworkConnectionInfo_MobileSubtype_UnknownMobileSubtype,
        .core.name = "mobileSubtype",
        .core.dataTypeSpecific.enumDescFunc = FPRMSGNetworkConnectionInfo_MobileSubtype_EnumDescriptor,
        .core.number = FPRMSGNetworkConnectionInfo_FieldNumber_MobileSubtype,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(FPRMSGNetworkConnectionInfo__storage_, mobileSubtype),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGNetworkConnectionInfo class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(FPRMSGNetworkConnectionInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum FPRMSGNetworkConnectionInfo_NetworkType

GPBEnumDescriptor *FPRMSGNetworkConnectionInfo_NetworkType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "None\000Mobile\000Wifi\000MobileMms\000MobileSupl\000Mo"
        "bileDun\000MobileHipri\000Wimax\000Bluetooth\000Dumm"
        "y\000Ethernet\000MobileFota\000MobileIms\000MobileCb"
        "s\000WifiP2P\000MobileIa\000MobileEmergency\000Proxy"
        "\000Vpn\000";
    static const int32_t values[] = {
        FPRMSGNetworkConnectionInfo_NetworkType_None,
        FPRMSGNetworkConnectionInfo_NetworkType_Mobile,
        FPRMSGNetworkConnectionInfo_NetworkType_Wifi,
        FPRMSGNetworkConnectionInfo_NetworkType_MobileMms,
        FPRMSGNetworkConnectionInfo_NetworkType_MobileSupl,
        FPRMSGNetworkConnectionInfo_NetworkType_MobileDun,
        FPRMSGNetworkConnectionInfo_NetworkType_MobileHipri,
        FPRMSGNetworkConnectionInfo_NetworkType_Wimax,
        FPRMSGNetworkConnectionInfo_NetworkType_Bluetooth,
        FPRMSGNetworkConnectionInfo_NetworkType_Dummy,
        FPRMSGNetworkConnectionInfo_NetworkType_Ethernet,
        FPRMSGNetworkConnectionInfo_NetworkType_MobileFota,
        FPRMSGNetworkConnectionInfo_NetworkType_MobileIms,
        FPRMSGNetworkConnectionInfo_NetworkType_MobileCbs,
        FPRMSGNetworkConnectionInfo_NetworkType_WifiP2P,
        FPRMSGNetworkConnectionInfo_NetworkType_MobileIa,
        FPRMSGNetworkConnectionInfo_NetworkType_MobileEmergency,
        FPRMSGNetworkConnectionInfo_NetworkType_Proxy,
        FPRMSGNetworkConnectionInfo_NetworkType_Vpn,
    };
    static const char *extraTextFormatInfo = "\001\016d\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FPRMSGNetworkConnectionInfo_NetworkType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FPRMSGNetworkConnectionInfo_NetworkType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FPRMSGNetworkConnectionInfo_NetworkType_IsValidValue(int32_t value__) {
  switch (value__) {
    case FPRMSGNetworkConnectionInfo_NetworkType_None:
    case FPRMSGNetworkConnectionInfo_NetworkType_Mobile:
    case FPRMSGNetworkConnectionInfo_NetworkType_Wifi:
    case FPRMSGNetworkConnectionInfo_NetworkType_MobileMms:
    case FPRMSGNetworkConnectionInfo_NetworkType_MobileSupl:
    case FPRMSGNetworkConnectionInfo_NetworkType_MobileDun:
    case FPRMSGNetworkConnectionInfo_NetworkType_MobileHipri:
    case FPRMSGNetworkConnectionInfo_NetworkType_Wimax:
    case FPRMSGNetworkConnectionInfo_NetworkType_Bluetooth:
    case FPRMSGNetworkConnectionInfo_NetworkType_Dummy:
    case FPRMSGNetworkConnectionInfo_NetworkType_Ethernet:
    case FPRMSGNetworkConnectionInfo_NetworkType_MobileFota:
    case FPRMSGNetworkConnectionInfo_NetworkType_MobileIms:
    case FPRMSGNetworkConnectionInfo_NetworkType_MobileCbs:
    case FPRMSGNetworkConnectionInfo_NetworkType_WifiP2P:
    case FPRMSGNetworkConnectionInfo_NetworkType_MobileIa:
    case FPRMSGNetworkConnectionInfo_NetworkType_MobileEmergency:
    case FPRMSGNetworkConnectionInfo_NetworkType_Proxy:
    case FPRMSGNetworkConnectionInfo_NetworkType_Vpn:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FPRMSGNetworkConnectionInfo_MobileSubtype

GPBEnumDescriptor *FPRMSGNetworkConnectionInfo_MobileSubtype_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownMobileSubtype\000Gprs\000Edge\000Umts\000Cdma"
        "\000Evdo0\000EvdoA\000Rtt\000Hsdpa\000Hsupa\000Hspa\000Iden\000E"
        "vdoB\000Lte\000Ehrpd\000Hspap\000Gsm\000TdScdma\000Iwlan\000L"
        "teCa\000Combined\000";
    static const int32_t values[] = {
        FPRMSGNetworkConnectionInfo_MobileSubtype_UnknownMobileSubtype,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Gprs,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Edge,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Umts,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Cdma,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Evdo0,
        FPRMSGNetworkConnectionInfo_MobileSubtype_EvdoA,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Rtt,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Hsdpa,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Hsupa,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Hspa,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Iden,
        FPRMSGNetworkConnectionInfo_MobileSubtype_EvdoB,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Lte,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Ehrpd,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Hspap,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Gsm,
        FPRMSGNetworkConnectionInfo_MobileSubtype_TdScdma,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Iwlan,
        FPRMSGNetworkConnectionInfo_MobileSubtype_LteCa,
        FPRMSGNetworkConnectionInfo_MobileSubtype_Combined,
    };
    static const char *extraTextFormatInfo = "\001\005d\201\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FPRMSGNetworkConnectionInfo_MobileSubtype)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FPRMSGNetworkConnectionInfo_MobileSubtype_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FPRMSGNetworkConnectionInfo_MobileSubtype_IsValidValue(int32_t value__) {
  switch (value__) {
    case FPRMSGNetworkConnectionInfo_MobileSubtype_UnknownMobileSubtype:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Gprs:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Edge:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Umts:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Cdma:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Evdo0:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_EvdoA:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Rtt:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Hsdpa:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Hsupa:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Hspa:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Iden:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_EvdoB:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Lte:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Ehrpd:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Hspap:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Gsm:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_TdScdma:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Iwlan:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_LteCa:
    case FPRMSGNetworkConnectionInfo_MobileSubtype_Combined:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - FPRMSGIosApplicationInfo

@implementation FPRMSGIosApplicationInfo

@dynamic hasSdkVersion, sdkVersion;
@dynamic hasBundleShortVersion, bundleShortVersion;
@dynamic hasMccMnc, mccMnc;
@dynamic hasNetworkConnectionInfo, networkConnectionInfo;

typedef struct FPRMSGIosApplicationInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *sdkVersion;
  NSString *bundleShortVersion;
  NSString *mccMnc;
  FPRMSGNetworkConnectionInfo *networkConnectionInfo;
} FPRMSGIosApplicationInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sdkVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGIosApplicationInfo_FieldNumber_SdkVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGIosApplicationInfo__storage_, sdkVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundleShortVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGIosApplicationInfo_FieldNumber_BundleShortVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPRMSGIosApplicationInfo__storage_, bundleShortVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mccMnc",
        .dataTypeSpecific.clazz = Nil,
        .number = FPRMSGIosApplicationInfo_FieldNumber_MccMnc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FPRMSGIosApplicationInfo__storage_, mccMnc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "networkConnectionInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(FPRMSGNetworkConnectionInfo),
        .number = FPRMSGIosApplicationInfo_FieldNumber_NetworkConnectionInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FPRMSGIosApplicationInfo__storage_, networkConnectionInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGIosApplicationInfo class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGIosApplicationInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPRMSGTransportInfo

@implementation FPRMSGTransportInfo

@dynamic hasDispatchDestination, dispatchDestination;

typedef struct FPRMSGTransportInfo__storage_ {
  uint32_t _has_storage_[1];
  FPRMSGTransportInfo_DispatchDestination dispatchDestination;
} FPRMSGTransportInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dispatchDestination",
        .dataTypeSpecific.enumDescFunc = FPRMSGTransportInfo_DispatchDestination_EnumDescriptor,
        .number = FPRMSGTransportInfo_FieldNumber_DispatchDestination,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPRMSGTransportInfo__storage_, dispatchDestination),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPRMSGTransportInfo class]
                                     rootClass:[FPRMSGPerfMetricRoot class]
                                          file:FPRMSGPerfMetricRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPRMSGTransportInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum FPRMSGTransportInfo_DispatchDestination

GPBEnumDescriptor *FPRMSGTransportInfo_DispatchDestination_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SourceUnknown\000FlLegacyV1\000";
    static const int32_t values[] = {
        FPRMSGTransportInfo_DispatchDestination_SourceUnknown,
        FPRMSGTransportInfo_DispatchDestination_FlLegacyV1,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FPRMSGTransportInfo_DispatchDestination)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FPRMSGTransportInfo_DispatchDestination_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FPRMSGTransportInfo_DispatchDestination_IsValidValue(int32_t value__) {
  switch (value__) {
    case FPRMSGTransportInfo_DispatchDestination_SourceUnknown:
    case FPRMSGTransportInfo_DispatchDestination_FlLegacyV1:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
