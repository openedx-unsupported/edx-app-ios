// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perf_metric.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30004
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30004 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class FPRMSGAndroidApplicationInfo;
@class FPRMSGAndroidMemoryReading;
@class FPRMSGApplicationInfo;
@class FPRMSGCpuMetricReading;
@class FPRMSGGaugeMetadata;
@class FPRMSGGaugeMetric;
@class FPRMSGIosApplicationInfo;
@class FPRMSGIosMemoryReading;
@class FPRMSGNetworkConnectionInfo;
@class FPRMSGNetworkRequestMetric;
@class FPRMSGPerfSession;
@class FPRMSGTraceMetric;
@class FPRMSGTransportInfo;
@class FPRMSGWebApplicationInfo;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum FPRMSGApplicationProcessState

/** Metadata about the state of application process during metrics collection. */
typedef GPB_ENUM(FPRMSGApplicationProcessState) {
  /** Unspecified application process state. */
  FPRMSGApplicationProcessState_ApplicationProcessStateUnknown = 0,

  /** Application process was in foreground */
  FPRMSGApplicationProcessState_Foreground = 1,

  /** Application process was in background */
  FPRMSGApplicationProcessState_Background = 2,

  /**
   * Application process was both in foreground and background for the duration
   * of metrics collection.
   **/
  FPRMSGApplicationProcessState_ForegroundBackground = 3,
};

GPBEnumDescriptor *FPRMSGApplicationProcessState_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL FPRMSGApplicationProcessState_IsValidValue(int32_t value);

#pragma mark - Enum FPRMSGSessionVerbosity

/**
 * The level of detailed information that is captured in a Perf Session, known
 * as a session's verbosity. For different session we collect different levels
 * of detailed information (or none at all) to avoid penalizing the same device
 * constantly.
 **/
typedef GPB_ENUM(FPRMSGSessionVerbosity) {
  /** Session doesn't have detailed information. */
  FPRMSGSessionVerbosity_SessionVerbosityNone = 0,

  /**
   * Session has gauges and system events information.
   **/
  FPRMSGSessionVerbosity_GaugesAndSystemEvents = 1,
};

GPBEnumDescriptor *FPRMSGSessionVerbosity_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL FPRMSGSessionVerbosity_IsValidValue(int32_t value);

#pragma mark - Enum FPRMSGVisibilityState

/** Visibility state for a web page. */
typedef GPB_ENUM(FPRMSGVisibilityState) {
  /** Unspecified visibility state. */
  FPRMSGVisibilityState_VisibilityStateUnknown = 0,

  /**
   * The page is at least partially visible. In practice this means the page
   * is in the foreground tab of a non-minimized window.
   **/
  FPRMSGVisibilityState_Visible = 1,

  /** The page's content is not visible to the user. */
  FPRMSGVisibilityState_Hidden = 2,

  /** The page's content is being prerendered and is not visible to the user. */
  FPRMSGVisibilityState_Prerender = 3,

  /** The page is in the process of being unloaded from memory. */
  FPRMSGVisibilityState_Unloaded = 4,
};

GPBEnumDescriptor *FPRMSGVisibilityState_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL FPRMSGVisibilityState_IsValidValue(int32_t value);

#pragma mark - Enum FPRMSGServiceWorkerStatus

/** Service worker status for a web page. */
typedef GPB_ENUM(FPRMSGServiceWorkerStatus) {
  /** Unspecified service worker status. */
  FPRMSGServiceWorkerStatus_ServiceWorkerStatusUnknown = 0,

  /** Service worker not supported by the browser. */
  FPRMSGServiceWorkerStatus_Unsupported = 1,

  /** Service worker controlled page. */
  FPRMSGServiceWorkerStatus_Controlled = 2,

  /** Page not controlled by a service worker. */
  FPRMSGServiceWorkerStatus_Uncontrolled = 3,
};

GPBEnumDescriptor *FPRMSGServiceWorkerStatus_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL FPRMSGServiceWorkerStatus_IsValidValue(int32_t value);

#pragma mark - Enum FPRMSGEffectiveConnectionType

/**
 * Effective connection type for a web application, defined from
 * https://wicg.github.io/netinfo/#effective-connection-types
 **/
typedef GPB_ENUM(FPRMSGEffectiveConnectionType) {
  FPRMSGEffectiveConnectionType_EffectiveConnectionTypeUnknown = 0,

  /** Maximum downlink speed 50kbs */
  FPRMSGEffectiveConnectionType_EffectiveConnectionTypeSlow2G = 1,

  /** Maximum downlink speed 70kbs */
  FPRMSGEffectiveConnectionType_EffectiveConnectionType2G = 2,

  /** Maximum downlink speed 700kbs */
  FPRMSGEffectiveConnectionType_EffectiveConnectionType3G = 3,

  /** Maximum downlink speed Infinity */
  FPRMSGEffectiveConnectionType_EffectiveConnectionType4G = 4,
};

GPBEnumDescriptor *FPRMSGEffectiveConnectionType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL FPRMSGEffectiveConnectionType_IsValidValue(int32_t value);

#pragma mark - Enum FPRMSGNetworkRequestMetric_HttpMethod

/**
 * Supported HTTP methods for aggregating network requests. All network
 * requests that can not be classified into the 9 methods below should be set
 * to HTTP_METHOD_UNKNOWN.
 **/
typedef GPB_ENUM(FPRMSGNetworkRequestMetric_HttpMethod) {
  FPRMSGNetworkRequestMetric_HttpMethod_HTTPMethodUnknown = 0,
  FPRMSGNetworkRequestMetric_HttpMethod_Get = 1,
  FPRMSGNetworkRequestMetric_HttpMethod_Put = 2,
  FPRMSGNetworkRequestMetric_HttpMethod_Post = 3,
  FPRMSGNetworkRequestMetric_HttpMethod_Delete = 4,
  FPRMSGNetworkRequestMetric_HttpMethod_Head = 5,
  FPRMSGNetworkRequestMetric_HttpMethod_Patch = 6,
  FPRMSGNetworkRequestMetric_HttpMethod_Options = 7,
  FPRMSGNetworkRequestMetric_HttpMethod_Trace = 8,
  FPRMSGNetworkRequestMetric_HttpMethod_Connect = 9,
};

GPBEnumDescriptor *FPRMSGNetworkRequestMetric_HttpMethod_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL FPRMSGNetworkRequestMetric_HttpMethod_IsValidValue(int32_t value);

#pragma mark - Enum FPRMSGNetworkRequestMetric_NetworkClientErrorReason

/** Info about the type of client error during network call. */
typedef GPB_ENUM(FPRMSGNetworkRequestMetric_NetworkClientErrorReason) {
  /** Unspecified Network Client Error Reason. */
  FPRMSGNetworkRequestMetric_NetworkClientErrorReason_NetworkClientErrorReasonUnknown = 0,

  /** No attempt made to classify the error. */
  FPRMSGNetworkRequestMetric_NetworkClientErrorReason_GenericClientError = 1,
};

GPBEnumDescriptor *FPRMSGNetworkRequestMetric_NetworkClientErrorReason_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL FPRMSGNetworkRequestMetric_NetworkClientErrorReason_IsValidValue(int32_t value);

#pragma mark - Enum FPRMSGNetworkConnectionInfo_NetworkType

typedef GPB_ENUM(FPRMSGNetworkConnectionInfo_NetworkType) {
  FPRMSGNetworkConnectionInfo_NetworkType_None = -1,
  FPRMSGNetworkConnectionInfo_NetworkType_Mobile = 0,
  FPRMSGNetworkConnectionInfo_NetworkType_Wifi = 1,
  FPRMSGNetworkConnectionInfo_NetworkType_MobileMms = 2,
  FPRMSGNetworkConnectionInfo_NetworkType_MobileSupl = 3,
  FPRMSGNetworkConnectionInfo_NetworkType_MobileDun = 4,
  FPRMSGNetworkConnectionInfo_NetworkType_MobileHipri = 5,
  FPRMSGNetworkConnectionInfo_NetworkType_Wimax = 6,
  FPRMSGNetworkConnectionInfo_NetworkType_Bluetooth = 7,
  FPRMSGNetworkConnectionInfo_NetworkType_Dummy = 8,
  FPRMSGNetworkConnectionInfo_NetworkType_Ethernet = 9,
  FPRMSGNetworkConnectionInfo_NetworkType_MobileFota = 10,
  FPRMSGNetworkConnectionInfo_NetworkType_MobileIms = 11,
  FPRMSGNetworkConnectionInfo_NetworkType_MobileCbs = 12,
  FPRMSGNetworkConnectionInfo_NetworkType_WifiP2P = 13,
  FPRMSGNetworkConnectionInfo_NetworkType_MobileIa = 14,
  FPRMSGNetworkConnectionInfo_NetworkType_MobileEmergency = 15,
  FPRMSGNetworkConnectionInfo_NetworkType_Proxy = 16,
  FPRMSGNetworkConnectionInfo_NetworkType_Vpn = 17,
};

GPBEnumDescriptor *FPRMSGNetworkConnectionInfo_NetworkType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL FPRMSGNetworkConnectionInfo_NetworkType_IsValidValue(int32_t value);

#pragma mark - Enum FPRMSGNetworkConnectionInfo_MobileSubtype

typedef GPB_ENUM(FPRMSGNetworkConnectionInfo_MobileSubtype) {
  FPRMSGNetworkConnectionInfo_MobileSubtype_UnknownMobileSubtype = 0,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Gprs = 1,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Edge = 2,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Umts = 3,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Cdma = 4,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Evdo0 = 5,
  FPRMSGNetworkConnectionInfo_MobileSubtype_EvdoA = 6,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Rtt = 7,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Hsdpa = 8,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Hsupa = 9,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Hspa = 10,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Iden = 11,
  FPRMSGNetworkConnectionInfo_MobileSubtype_EvdoB = 12,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Lte = 13,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Ehrpd = 14,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Hspap = 15,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Gsm = 16,
  FPRMSGNetworkConnectionInfo_MobileSubtype_TdScdma = 17,
  FPRMSGNetworkConnectionInfo_MobileSubtype_Iwlan = 18,
  FPRMSGNetworkConnectionInfo_MobileSubtype_LteCa = 19,

  /**
   * COMBINED has value -1 in NetworkIdentity.java, but is given the value
   * 100 here to save (disk) space. The value -1 takes up the full 10 bytes in
   * a varint for enums, but the value 100 only takes up 1 byte.
   **/
  FPRMSGNetworkConnectionInfo_MobileSubtype_Combined = 100,
};

GPBEnumDescriptor *FPRMSGNetworkConnectionInfo_MobileSubtype_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL FPRMSGNetworkConnectionInfo_MobileSubtype_IsValidValue(int32_t value);

#pragma mark - Enum FPRMSGTransportInfo_DispatchDestination

/** Dispatch destination for the event. */
typedef GPB_ENUM(FPRMSGTransportInfo_DispatchDestination) {
  /** Reserved */
  FPRMSGTransportInfo_DispatchDestination_SourceUnknown = 0,

  /** Firelog legacy endpoint */
  FPRMSGTransportInfo_DispatchDestination_FlLegacyV1 = 1,
};

GPBEnumDescriptor *FPRMSGTransportInfo_DispatchDestination_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL FPRMSGTransportInfo_DispatchDestination_IsValidValue(int32_t value);

#pragma mark - FPRMSGPerfMetricRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
GPB_FINAL @interface FPRMSGPerfMetricRoot : GPBRootObject
@end

#pragma mark - FPRMSGPerfMetric

typedef GPB_ENUM(FPRMSGPerfMetric_FieldNumber) {
  FPRMSGPerfMetric_FieldNumber_ApplicationInfo = 1,
  FPRMSGPerfMetric_FieldNumber_TraceMetric = 2,
  FPRMSGPerfMetric_FieldNumber_NetworkRequestMetric = 3,
  FPRMSGPerfMetric_FieldNumber_GaugeMetric = 4,
  FPRMSGPerfMetric_FieldNumber_TransportInfo = 5,
};

/**
 * Single unit of performance data collected from firebase integrated 3P apps by
 * the firebase performance sdk. This will be an an extension to
 * GWSLogEntryProto and will correspond to one record in the RecordIO logs
 * generated by clearcut. Every firebase performance related event logged to
 * clearcut/Firelog by the sdk will encapsulate one instance of this object.
 *
 * Next tag: 6
 **/
GPB_FINAL @interface FPRMSGPerfMetric : GPBMessage

/**
 * Additional metadata about an application and its state (including state of
 * the device at runtime) that is not provided by clearcut.
 **/
@property(nonatomic, readwrite, strong, null_resettable) FPRMSGApplicationInfo *applicationInfo;
/** Test to see if @c applicationInfo has been set. */
@property(nonatomic, readwrite) BOOL hasApplicationInfo;

/**
 * A metric which represents the performance statistics collected within an
 * instrumented trace.
 **/
@property(nonatomic, readwrite, strong, null_resettable) FPRMSGTraceMetric *traceMetric;
/** Test to see if @c traceMetric has been set. */
@property(nonatomic, readwrite) BOOL hasTraceMetric;

/**
 * A metric which represents the network latency, bandwidth and network
 * connection info about a network request captured by the firebase sdk.
 **/
@property(nonatomic, readwrite, strong, null_resettable) FPRMSGNetworkRequestMetric *networkRequestMetric;
/** Test to see if @c networkRequestMetric has been set. */
@property(nonatomic, readwrite) BOOL hasNetworkRequestMetric;

/**
 * A metric which represents session gauges, such as cpu, memory, battery,
 * within a session.
 **/
@property(nonatomic, readwrite, strong, null_resettable) FPRMSGGaugeMetric *gaugeMetric;
/** Test to see if @c gaugeMetric has been set. */
@property(nonatomic, readwrite) BOOL hasGaugeMetric;

/**
 * A metric which represents the transport related information.
 * When transport_info field is empty, it means the message is from clearcut.
 **/
@property(nonatomic, readwrite, strong, null_resettable) FPRMSGTransportInfo *transportInfo;
/** Test to see if @c transportInfo has been set. */
@property(nonatomic, readwrite) BOOL hasTransportInfo;

@end

#pragma mark - FPRMSGTraceMetric

typedef GPB_ENUM(FPRMSGTraceMetric_FieldNumber) {
  FPRMSGTraceMetric_FieldNumber_Name = 1,
  FPRMSGTraceMetric_FieldNumber_IsAuto = 2,
  FPRMSGTraceMetric_FieldNumber_ClientStartTimeUs = 4,
  FPRMSGTraceMetric_FieldNumber_DurationUs = 5,
  FPRMSGTraceMetric_FieldNumber_Counters = 6,
  FPRMSGTraceMetric_FieldNumber_SubtracesArray = 7,
  FPRMSGTraceMetric_FieldNumber_CustomAttributes = 8,
  FPRMSGTraceMetric_FieldNumber_PerfSessionsArray = 9,
};

/**
 * Metric which represents everything collected in the span of a trace. A trace
 * may be further divided into subtraces.
 * The trace can either be a default out of the box trace which is a
 * part of the default instrumentation provided by the firebase performance sdk
 * or a custom trace instrumented by the app developer using the sdk apis.
 *
 * Next tag: 10
 **/
GPB_FINAL @interface FPRMSGTraceMetric : GPBMessage

/**
 * The name of the trace. This could either be a user defined name for the
 * developer instrumented custom traces or a default for traces automatically
 * instrumented by the Firebase Performance SDK. The max length of 64
 * characters will be enforced by the sdk.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *name;
/** Test to see if @c name has been set. */
@property(nonatomic, readwrite) BOOL hasName;

/**
 * If true, then this is considered to be a trace automatically instrumented
 * by the performance sdk. Otherwise, it is considered to be a custom trace
 * instrumented by the developer using firebase perf sdk apis.
 **/
@property(nonatomic, readwrite) BOOL isAuto;

@property(nonatomic, readwrite) BOOL hasIsAuto;
/**
 * The timestamp in microseconds since epoch when the trace was started. This
 * time is recorded using the device clock.
 **/
@property(nonatomic, readwrite) int64_t clientStartTimeUs;

@property(nonatomic, readwrite) BOOL hasClientStartTimeUs;
/** The duration of the trace in microseconds. */
@property(nonatomic, readwrite) int64_t durationUs;

@property(nonatomic, readwrite) BOOL hasDurationUs;
/** A map of custom or default counter names to values. */
@property(nonatomic, readwrite, strong, null_resettable) GPBStringInt64Dictionary *counters;
/** The number of items in @c counters without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger counters_Count;

/**
 * The following restrictions are currently enforced by the sdk on subtraces:
 * Subtraces should only have 1 level of nesting.
 * Subtraces should be non overlapping.
 * Subtraces should be continuous, i.e no gaps between consecutive subtraces.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<FPRMSGTraceMetric*> *subtracesArray;
/** The number of items in @c subtracesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger subtracesArray_Count;

/** A map of trace-level custom attribute names to values. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableDictionary<NSString*, NSString*> *customAttributes;
/** The number of items in @c customAttributes without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger customAttributes_Count;

/**
 * Sessions across which the trace spanned. A session lasts from one
 * change in the app state (foreground/background) to the next. Basically
 * every foreground and background session gets it's own session id. A trace
 * may span across multiple such sessions. So we need a list to identify which
 * sessions it spanned across.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<FPRMSGPerfSession*> *perfSessionsArray;
/** The number of items in @c perfSessionsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger perfSessionsArray_Count;

@end

#pragma mark - FPRMSGNetworkRequestMetric

typedef GPB_ENUM(FPRMSGNetworkRequestMetric_FieldNumber) {
  FPRMSGNetworkRequestMetric_FieldNumber_URL = 1,
  FPRMSGNetworkRequestMetric_FieldNumber_HTTPMethod = 2,
  FPRMSGNetworkRequestMetric_FieldNumber_RequestPayloadBytes = 3,
  FPRMSGNetworkRequestMetric_FieldNumber_ResponsePayloadBytes = 4,
  FPRMSGNetworkRequestMetric_FieldNumber_HTTPResponseCode = 5,
  FPRMSGNetworkRequestMetric_FieldNumber_ResponseContentType = 6,
  FPRMSGNetworkRequestMetric_FieldNumber_ClientStartTimeUs = 7,
  FPRMSGNetworkRequestMetric_FieldNumber_TimeToRequestCompletedUs = 8,
  FPRMSGNetworkRequestMetric_FieldNumber_TimeToResponseInitiatedUs = 9,
  FPRMSGNetworkRequestMetric_FieldNumber_TimeToResponseCompletedUs = 10,
  FPRMSGNetworkRequestMetric_FieldNumber_NetworkClientErrorReason = 11,
  FPRMSGNetworkRequestMetric_FieldNumber_CustomAttributes = 12,
  FPRMSGNetworkRequestMetric_FieldNumber_PerfSessionsArray = 13,
};

/**
 * Metric which represents the latency, bandwidth consumption and other details
 * about a network request captured by the firebase sdk.
 *
 * Next tag: 14
 **/
GPB_FINAL @interface FPRMSGNetworkRequestMetric : GPBMessage

/**
 * The parameterless url to which the network request was made. The sdk will
 * redact the unnecessary components of the URL and only log the components
 * which are useful. For a url of the form
 * scheme://host[:port]/path[?params][#fragment], the sdk should only log
 * scheme://host[:port]/path
 * Example:
 * Captured Url: https://wwww.google.com/maps/cities#seattle?id=123
 * Logged Url: https://wwww.google.com/maps/cities
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *URL;
/** Test to see if @c URL has been set. */
@property(nonatomic, readwrite) BOOL hasURL;

/**
 * The HTTP verb for the network request. Common values include GET,
 * PUT, POST and DELETE
 **/
@property(nonatomic, readwrite) FPRMSGNetworkRequestMetric_HttpMethod HTTPMethod;

@property(nonatomic, readwrite) BOOL hasHTTPMethod;
/** The size of the payload in the request. */
@property(nonatomic, readwrite) int64_t requestPayloadBytes;

@property(nonatomic, readwrite) BOOL hasRequestPayloadBytes;
/** The size of the payload in the response. */
@property(nonatomic, readwrite) int64_t responsePayloadBytes;

@property(nonatomic, readwrite) BOOL hasResponsePayloadBytes;
/**
 * The client error received from the networking library.
 * Do not record a client error if we have HTTP response code available.
 **/
@property(nonatomic, readwrite) FPRMSGNetworkRequestMetric_NetworkClientErrorReason networkClientErrorReason;

@property(nonatomic, readwrite) BOOL hasNetworkClientErrorReason;
/** The Http response code received from the server. */
@property(nonatomic, readwrite) int32_t HTTPResponseCode;

@property(nonatomic, readwrite) BOOL hasHTTPResponseCode;
/** The value of the content type header in the response. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *responseContentType;
/** Test to see if @c responseContentType has been set. */
@property(nonatomic, readwrite) BOOL hasResponseContentType;

/**
 * The timestamp in microseconds since epoch when the network request was
 * initiated. This time is recorded using the device clock.
 **/
@property(nonatomic, readwrite) int64_t clientStartTimeUs;

@property(nonatomic, readwrite) BOOL hasClientStartTimeUs;
/**
 * The time in microseconds since the start of the network request and the
 * upload of the last request byte.
 **/
@property(nonatomic, readwrite) int64_t timeToRequestCompletedUs;

@property(nonatomic, readwrite) BOOL hasTimeToRequestCompletedUs;
/**
 * The time in microseconds between the start of the network request and the
 * receipt of the first byte of the response headers.
 **/
@property(nonatomic, readwrite) int64_t timeToResponseInitiatedUs;

@property(nonatomic, readwrite) BOOL hasTimeToResponseInitiatedUs;
/**
 * The time in microseconds between the start of the network request and the
 * receipt of the last response byte.
 **/
@property(nonatomic, readwrite) int64_t timeToResponseCompletedUs;

@property(nonatomic, readwrite) BOOL hasTimeToResponseCompletedUs;
/** A map of network-level custom attribute names to values. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableDictionary<NSString*, NSString*> *customAttributes;
/** The number of items in @c customAttributes without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger customAttributes_Count;

/**
 * Sessions across which the network request spanned. A session lasts
 * from one change in the app state (foreground/background) to the next.
 * Basically every foreground and background session gets it's own session id.
 * A network request may span across multiple such sessions. So we need a list
 * to identify which sessions it spanned across.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<FPRMSGPerfSession*> *perfSessionsArray;
/** The number of items in @c perfSessionsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger perfSessionsArray_Count;

@end

#pragma mark - FPRMSGPerfSession

typedef GPB_ENUM(FPRMSGPerfSession_FieldNumber) {
  FPRMSGPerfSession_FieldNumber_SessionId = 1,
  FPRMSGPerfSession_FieldNumber_SessionVerbosityArray = 2,
};

/**
 * Metadata about a session and the amount of detail information it contains.
 **/
GPB_FINAL @interface FPRMSGPerfSession : GPBMessage

/** The id of a session. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *sessionId;
/** Test to see if @c sessionId has been set. */
@property(nonatomic, readwrite) BOOL hasSessionId;

/** The level of amount of detailed information that this session captures. */
// |sessionVerbosityArray| contains |FPRMSGSessionVerbosity|
@property(nonatomic, readwrite, strong, null_resettable) GPBEnumArray *sessionVerbosityArray;
/** The number of items in @c sessionVerbosityArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger sessionVerbosityArray_Count;

@end

#pragma mark - FPRMSGGaugeMetric

typedef GPB_ENUM(FPRMSGGaugeMetric_FieldNumber) {
  FPRMSGGaugeMetric_FieldNumber_SessionId = 1,
  FPRMSGGaugeMetric_FieldNumber_CpuMetricReadingsArray = 2,
  FPRMSGGaugeMetric_FieldNumber_GaugeMetadata = 3,
  FPRMSGGaugeMetric_FieldNumber_AndroidMemoryReadingsArray = 4,
  FPRMSGGaugeMetric_FieldNumber_IosMemoryReadingsArray = 5,
};

/**
 * Metric which represents gauges collected during the span of a session,
 * including cpu, memory, battery, etc.
 * The gauges will be collected by our own sdk and be purely numeric readings,
 * user cannot pass any information here, so cannot contain PIIs.
 *
 * Next tag: 6
 **/
GPB_FINAL @interface FPRMSGGaugeMetric : GPBMessage

/**
 * Identifier of the session in which this gauge reading takes place.
 * A session_id is specific to a device instance, and is used to tie gauge
 * metrics to other peer traces and network requests that occurs during
 * the session.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *sessionId;
/** Test to see if @c sessionId has been set. */
@property(nonatomic, readwrite) BOOL hasSessionId;

/** Metadata of gauge metrics whose value stay constant throughout the session. */
@property(nonatomic, readwrite, strong, null_resettable) FPRMSGGaugeMetadata *gaugeMetadata;
/** Test to see if @c gaugeMetadata has been set. */
@property(nonatomic, readwrite) BOOL hasGaugeMetadata;

/** List of cpu gauge readings recorded in the session. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<FPRMSGCpuMetricReading*> *cpuMetricReadingsArray;
/** The number of items in @c cpuMetricReadingsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger cpuMetricReadingsArray_Count;

/** List of Android memory readings recorded, absent for iOS apps. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<FPRMSGAndroidMemoryReading*> *androidMemoryReadingsArray;
/** The number of items in @c androidMemoryReadingsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger androidMemoryReadingsArray_Count;

/** List of iOS memory readings recorded, absent for Android apps. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<FPRMSGIosMemoryReading*> *iosMemoryReadingsArray;
/** The number of items in @c iosMemoryReadingsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger iosMemoryReadingsArray_Count;

@end

#pragma mark - FPRMSGCpuMetricReading

typedef GPB_ENUM(FPRMSGCpuMetricReading_FieldNumber) {
  FPRMSGCpuMetricReading_FieldNumber_ClientTimeUs = 1,
  FPRMSGCpuMetricReading_FieldNumber_UserTimeUs = 2,
  FPRMSGCpuMetricReading_FieldNumber_SystemTimeUs = 3,
};

/**
 * One reading of cpu gauge metric.
 *
 * Next tag: 4
 **/
GPB_FINAL @interface FPRMSGCpuMetricReading : GPBMessage

/**
 * The timestamp in microseconds since epoch when this snapshot took place.
 * This time is recorded using the device clock.
 **/
@property(nonatomic, readwrite) int64_t clientTimeUs;

@property(nonatomic, readwrite) BOOL hasClientTimeUs;
/** The total user cpu time since process started in microseconds. */
@property(nonatomic, readwrite) int64_t userTimeUs;

@property(nonatomic, readwrite) BOOL hasUserTimeUs;
/** The total system cpu time since process started in microseconds. */
@property(nonatomic, readwrite) int64_t systemTimeUs;

@property(nonatomic, readwrite) BOOL hasSystemTimeUs;
@end

#pragma mark - FPRMSGIosMemoryReading

typedef GPB_ENUM(FPRMSGIosMemoryReading_FieldNumber) {
  FPRMSGIosMemoryReading_FieldNumber_ClientTimeUs = 1,
  FPRMSGIosMemoryReading_FieldNumber_UsedAppHeapMemoryKb = 2,
  FPRMSGIosMemoryReading_FieldNumber_FreeAppHeapMemoryKb = 3,
};

/**
 * One reading of iOS memory gauge metric.
 *
 * Next tag: 4
 **/
GPB_FINAL @interface FPRMSGIosMemoryReading : GPBMessage

/**
 * The timestamp in microseconds since epoch when this snapshot took place.
 * This time is recorded using the device clock.
 **/
@property(nonatomic, readwrite) int64_t clientTimeUs;

@property(nonatomic, readwrite) BOOL hasClientTimeUs;
/** The amount of heap memory that the app is using, in kilobytes. */
@property(nonatomic, readwrite) int32_t usedAppHeapMemoryKb;

@property(nonatomic, readwrite) BOOL hasUsedAppHeapMemoryKb;
/** The amount of heap memory that is free for the app to use, in kilobytes. */
@property(nonatomic, readwrite) int32_t freeAppHeapMemoryKb;

@property(nonatomic, readwrite) BOOL hasFreeAppHeapMemoryKb;
@end

#pragma mark - FPRMSGAndroidMemoryReading

typedef GPB_ENUM(FPRMSGAndroidMemoryReading_FieldNumber) {
  FPRMSGAndroidMemoryReading_FieldNumber_ClientTimeUs = 1,
  FPRMSGAndroidMemoryReading_FieldNumber_UsedAppJavaHeapMemoryKb = 2,
};

/**
 * One reading of Android memory gauge metric.
 * Note that this is cheap-to-capture memory reading, which is different from
 * application's summary of memory usage (expensive to capture). Summary of
 * memory usage will be captured at a much lower frequency in a different proto.
 *
 * Next tag: 3
 **/
GPB_FINAL @interface FPRMSGAndroidMemoryReading : GPBMessage

/**
 * The timestamp in microseconds since epoch when this snapshot took place.
 * This time is recorded using the device clock.
 **/
@property(nonatomic, readwrite) int64_t clientTimeUs;

@property(nonatomic, readwrite) BOOL hasClientTimeUs;
/** The amount of java heap memory that the app is using, in kilobytes. */
@property(nonatomic, readwrite) int32_t usedAppJavaHeapMemoryKb;

@property(nonatomic, readwrite) BOOL hasUsedAppJavaHeapMemoryKb;
@end

#pragma mark - FPRMSGGaugeMetadata

typedef GPB_ENUM(FPRMSGGaugeMetadata_FieldNumber) {
  FPRMSGGaugeMetadata_FieldNumber_ProcessName = 1,
  FPRMSGGaugeMetadata_FieldNumber_CpuClockRateKhz = 2,
  FPRMSGGaugeMetadata_FieldNumber_DeviceRamSizeKb = 3,
  FPRMSGGaugeMetadata_FieldNumber_MaxAppJavaHeapMemoryKb = 4,
  FPRMSGGaugeMetadata_FieldNumber_MaxEncouragedAppJavaHeapMemoryKb = 5,
  FPRMSGGaugeMetadata_FieldNumber_CpuProcessorCount = 6,
};

/**
 * Metadata about gauges of a session.
 * These are the gauge values that stay constant throughout the entire session.
 * Examples include maxAppJavaHeapMemory (max memory allowed for the app) and
 * cpuFrequency (frequency of cpu of the device that the app is running on).
 * As long as one GaugeMetadata is sent for a session, these metadata will be
 * available for all elements of the session. If multiple GaugeMetadata are sent
 * for the same session, they are expected to be identical.
 *
 * Next tag: 7
 **/
GPB_FINAL @interface FPRMSGGaugeMetadata : GPBMessage

/**
 * The process in which Firebase instance is initialized and collecting data.
 * Fireperf sdk collects information in the context of a process (instead of
 * the whole app). The process name helps developer identifies which process
 * are the gauge data coming from.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *processName;
/** Test to see if @c processName has been set. */
@property(nonatomic, readwrite) BOOL hasProcessName;

/** Clock rate of the cpu of the device, in kHz. */
@property(nonatomic, readwrite) int32_t cpuClockRateKhz;

@property(nonatomic, readwrite) BOOL hasCpuClockRateKhz;
/** The number of cpu cores that the device has. */
@property(nonatomic, readwrite) int32_t cpuProcessorCount;

@property(nonatomic, readwrite) BOOL hasCpuProcessorCount;
/** Size of RAM of the device, in kilobytes. */
@property(nonatomic, readwrite) int32_t deviceRamSizeKb;

@property(nonatomic, readwrite) BOOL hasDeviceRamSizeKb;
/**
 * Maximum amount of memory the app can use before an OutOfMemoryException
 * is triggered, in kilobytes.
 * Only present for Android apps.
 **/
@property(nonatomic, readwrite) int32_t maxAppJavaHeapMemoryKb;

@property(nonatomic, readwrite) BOOL hasMaxAppJavaHeapMemoryKb;
/**
 * The maximum amount of memory the app is encouraged to use to be properly
 * respectful of the limits of the client device.
 * Only present for Android apps.
 **/
@property(nonatomic, readwrite) int32_t maxEncouragedAppJavaHeapMemoryKb;

@property(nonatomic, readwrite) BOOL hasMaxEncouragedAppJavaHeapMemoryKb;
@end

#pragma mark - FPRMSGApplicationInfo

typedef GPB_ENUM(FPRMSGApplicationInfo_FieldNumber) {
  FPRMSGApplicationInfo_FieldNumber_GoogleAppId = 1,
  FPRMSGApplicationInfo_FieldNumber_AppInstanceId = 2,
  FPRMSGApplicationInfo_FieldNumber_AndroidAppInfo = 3,
  FPRMSGApplicationInfo_FieldNumber_IosAppInfo = 4,
  FPRMSGApplicationInfo_FieldNumber_ApplicationProcessState = 5,
  FPRMSGApplicationInfo_FieldNumber_CustomAttributes = 6,
  FPRMSGApplicationInfo_FieldNumber_WebAppInfo = 7,
};

/**
 * Additional metadata about an application and its state (including state of
 * the device at runtime) that is not provided by clearcut.
 *
 * Next tag: 8
 **/
GPB_FINAL @interface FPRMSGApplicationInfo : GPBMessage

/**
 * Identifier for the application that has been registered with firebase.
 * Contains pantheon project number, platform and the hash of the (package
 * name or bundle id) fields in hex.
 * [Version]:[Project Number]:[Platform]:[Hash(package_name/bundle_id)]
 * The app id contains Pantheon project number which is a GAIA ID that
 * identifies a particular organization or a customer.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *googleAppId;
/** Test to see if @c googleAppId has been set. */
@property(nonatomic, readwrite) BOOL hasGoogleAppId;

/**
 * The App Instance Id which is used to compute the distinct users for which
 * the metrics are recorded.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *appInstanceId;
/** Test to see if @c appInstanceId has been set. */
@property(nonatomic, readwrite) BOOL hasAppInstanceId;

/** Additional information specific to an android app. */
@property(nonatomic, readwrite, strong, null_resettable) FPRMSGAndroidApplicationInfo *androidAppInfo;
/** Test to see if @c androidAppInfo has been set. */
@property(nonatomic, readwrite) BOOL hasAndroidAppInfo;

/** Additional information specific to an ios app. */
@property(nonatomic, readwrite, strong, null_resettable) FPRMSGIosApplicationInfo *iosAppInfo;
/** Test to see if @c iosAppInfo has been set. */
@property(nonatomic, readwrite) BOOL hasIosAppInfo;

/** Additional information specific to a web app. */
@property(nonatomic, readwrite, strong, null_resettable) FPRMSGWebApplicationInfo *webAppInfo;
/** Test to see if @c webAppInfo has been set. */
@property(nonatomic, readwrite) BOOL hasWebAppInfo;

/** State of the application process during metric collection. */
@property(nonatomic, readwrite) FPRMSGApplicationProcessState applicationProcessState;

@property(nonatomic, readwrite) BOOL hasApplicationProcessState;
/** A map of global-level custom attribute names to values. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableDictionary<NSString*, NSString*> *customAttributes;
/** The number of items in @c customAttributes without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger customAttributes_Count;

@end

#pragma mark - FPRMSGWebApplicationInfo

typedef GPB_ENUM(FPRMSGWebApplicationInfo_FieldNumber) {
  FPRMSGWebApplicationInfo_FieldNumber_SdkVersion = 1,
  FPRMSGWebApplicationInfo_FieldNumber_PageURL = 2,
  FPRMSGWebApplicationInfo_FieldNumber_ServiceWorkerStatus = 3,
  FPRMSGWebApplicationInfo_FieldNumber_VisibilityState = 4,
  FPRMSGWebApplicationInfo_FieldNumber_EffectiveConnectionType = 5,
};

/**
 * Additional metadata about a web application that is not provided by
 * clearcut.
 *
 * Next tag: 6
 **/
GPB_FINAL @interface FPRMSGWebApplicationInfo : GPBMessage

/** The sdk version of the firebase perf web sdk. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *sdkVersion;
/** Test to see if @c sdkVersion has been set. */
@property(nonatomic, readwrite) BOOL hasSdkVersion;

/** The url of the web page from which this event occurs. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *pageURL;
/** Test to see if @c pageURL has been set. */
@property(nonatomic, readwrite) BOOL hasPageURL;

/** Service worker status of the web page. */
@property(nonatomic, readwrite) FPRMSGServiceWorkerStatus serviceWorkerStatus;

@property(nonatomic, readwrite) BOOL hasServiceWorkerStatus;
/** Visibility state of the web page. */
@property(nonatomic, readwrite) FPRMSGVisibilityState visibilityState;

@property(nonatomic, readwrite) BOOL hasVisibilityState;
/** Effective connection type of a web page. */
@property(nonatomic, readwrite) FPRMSGEffectiveConnectionType effectiveConnectionType;

@property(nonatomic, readwrite) BOOL hasEffectiveConnectionType;
@end

#pragma mark - FPRMSGAndroidApplicationInfo

typedef GPB_ENUM(FPRMSGAndroidApplicationInfo_FieldNumber) {
  FPRMSGAndroidApplicationInfo_FieldNumber_PackageName = 1,
  FPRMSGAndroidApplicationInfo_FieldNumber_SdkVersion = 2,
  FPRMSGAndroidApplicationInfo_FieldNumber_VersionName = 3,
};

/**
 * Additional metadata about an android application that is not provided by
 * clearcut.
 *
 * Next tag: 4
 **/
GPB_FINAL @interface FPRMSGAndroidApplicationInfo : GPBMessage

/**
 * The package name of the android application.
 * e.g com.google.android.apps.maps
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *packageName;
/** Test to see if @c packageName has been set. */
@property(nonatomic, readwrite) BOOL hasPackageName;

/** The sdk version of the firebase perf android sdk. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *sdkVersion;
/** Test to see if @c sdkVersion has been set. */
@property(nonatomic, readwrite) BOOL hasSdkVersion;

/**
 * The versionName of the android application as shown on the play store.
 * Clearcut logs the versionCode in the GWSLogEntryProto field:
 * PlayExtension.client_info.android_client_info.application_build
 * This field is necessary till clearcut supports logging version_name by
 * default: b/32584283
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *versionName;
/** Test to see if @c versionName has been set. */
@property(nonatomic, readwrite) BOOL hasVersionName;

@end

#pragma mark - FPRMSGNetworkConnectionInfo

typedef GPB_ENUM(FPRMSGNetworkConnectionInfo_FieldNumber) {
  FPRMSGNetworkConnectionInfo_FieldNumber_NetworkType = 1,
  FPRMSGNetworkConnectionInfo_FieldNumber_MobileSubtype = 2,
};

/**
 * To describe the network connectivity of the client.
 * Copied from android/play/playlog/proto/clientanalytics.proto
 * Next tag: 3
 **/
GPB_FINAL @interface FPRMSGNetworkConnectionInfo : GPBMessage

/**
 * The current network connectivity type when the event was logged in the
 * client
 **/
@property(nonatomic, readwrite) FPRMSGNetworkConnectionInfo_NetworkType networkType;

@property(nonatomic, readwrite) BOOL hasNetworkType;
/**
 * The current mobile connectivity subtype when the event was logged in the
 * client
 **/
@property(nonatomic, readwrite) FPRMSGNetworkConnectionInfo_MobileSubtype mobileSubtype;

@property(nonatomic, readwrite) BOOL hasMobileSubtype;
@end

#pragma mark - FPRMSGIosApplicationInfo

typedef GPB_ENUM(FPRMSGIosApplicationInfo_FieldNumber) {
  FPRMSGIosApplicationInfo_FieldNumber_SdkVersion = 2,
  FPRMSGIosApplicationInfo_FieldNumber_BundleShortVersion = 3,
  FPRMSGIosApplicationInfo_FieldNumber_MccMnc = 4,
  FPRMSGIosApplicationInfo_FieldNumber_NetworkConnectionInfo = 5,
};

/**
 * Additional metadata about an ios application that is not provided by
 * clearcut.
 *
 * Next tag: 6
 **/
GPB_FINAL @interface FPRMSGIosApplicationInfo : GPBMessage

/** The version of the firebase perf ios sdk. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *sdkVersion;
/** Test to see if @c sdkVersion has been set. */
@property(nonatomic, readwrite) BOOL hasSdkVersion;

/**
 * The CFBundleShortVersionString of the ios application bundle as shown on
 * the ios app store.
 * Clearcut logs the CFBundleVersion in the GWSLogEntryProto field:
 * PlayExtension.client_info.ios_client_info.application_build
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *bundleShortVersion;
/** Test to see if @c bundleShortVersion has been set. */
@property(nonatomic, readwrite) BOOL hasBundleShortVersion;

/**
 * The mobile country code / mobile network code (MCC/MNC) of the device's
 * SIM/home network (not the device's active network)
 * e.g., 310004 for Verizon USA.
 * This field should eventually move to PlaylogIosClientInfo. b/35763500
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *mccMnc;
/** Test to see if @c mccMnc has been set. */
@property(nonatomic, readwrite) BOOL hasMccMnc;

/** The network connectivity of the client when the fetch was done. */
@property(nonatomic, readwrite, strong, null_resettable) FPRMSGNetworkConnectionInfo *networkConnectionInfo;
/** Test to see if @c networkConnectionInfo has been set. */
@property(nonatomic, readwrite) BOOL hasNetworkConnectionInfo;

@end

#pragma mark - FPRMSGTransportInfo

typedef GPB_ENUM(FPRMSGTransportInfo_FieldNumber) {
  FPRMSGTransportInfo_FieldNumber_DispatchDestination = 1,
};

/**
 * Transport related metadata info.
 * Next tag: 2
 **/
GPB_FINAL @interface FPRMSGTransportInfo : GPBMessage

/** Destination to which the events are sent. */
@property(nonatomic, readwrite) FPRMSGTransportInfo_DispatchDestination dispatchDestination;

@property(nonatomic, readwrite) BOOL hasDispatchDestination;
@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
